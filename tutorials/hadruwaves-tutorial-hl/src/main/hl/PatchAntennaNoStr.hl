import package net.thevpc.scholar:hadruwaves#3.3.0;

class PatchAntennaNoStr {
  @enum class Mode{TE,TM}

  // ****************
  // Constants
  // ****************
  val N = 10 ;// number of modes TE or TM
  val P = 3  ;// number of test functions
  val Œµ·µ£ = 2.2;
  val Œµ = Œµ‚ÇÄ;
  val Œº = Œº‚ÇÄ;
  val r = (500 * MM) * 2;
  val a = 100.567 * MM;
  val b = 30 * MM;
  val ep = 1.59 * MM;
  val ap = 50 * MM;
  val bp = 5 * MM;
  val d = 2.812 * MM;
  val l = 5.69 * MM;
  val L = 22.760 * MM;
  val W = 5.989 * MM;
  val s = 0.786 * MM;
  val p = new Param<int>();
  val m = new Param<int>();
  val n = new Param<Mode>();
  var freq = 4.79 * GHZ; // 4.79 * GHZ; // to change


  val Z‚ÇÄ = ‚àö(Œº‚ÇÄ / Œµ‚ÇÄ);
  var Œª = C / freq;
  var Œ© = 2 * œÄ * freq;
  var k‚ÇÄ = 2 * œÄ / Œª;
  val box = domain(0.0 -> a, -b / 2 -> b / 2);
  val lineDomain = domain(0.0 -> l,-d / 2 -> d / 2);
  val srcExpr = normalize(domain(0.0 -> s, -d / 2 -> d / 2));



  // ****************
  // Build Parameters
  // ****************

  // Matrix A (Z operator), B (Source Projection), s‚Çö (g‚Çö f‚Çò‚Çô scalar product matrix)
  var A, B, s‚Çö;
  // g‚Çö (test functions list), z‚Çò‚Çô (modes impedance list), f‚Çò‚Çô (mode functions : Green Function)
  var g‚Çö, f‚Çò‚Çô;
  var z‚Çò‚Çô;

  //Unknown coefficients of Surface Current Density
  var X‚Çö = new Matrix(1,i->ƒâ);
  var Z·µ¢‚Çô = 0*√Æ;

  // Surface Current Density projected over Test functions
  var J‚Çú = 0*√™;
  // Surface Current Density projected over Mode functions
  var J‚Çò = 0*√™;
  // Surface Electric Field projected over Mode functions
  var E‚Çò = 0*√™;


  /**
    * build function to evaluate unknown according to parameters
    */
  fun build(double freq) {
    Maths.Config.setCacheEnabled(false);
    this.freq=freq;
     //reevaluate
    Œª = C / freq;
    Œ© = 2 * œÄ * freq;
    k‚ÇÄ = 2 * œÄ / Œª;
    
    var cr = chrono();
    val gpDef = ((cos((2 * p + 1) * œÄ * X / (2 * l)))  * lineDomain).with({title:"gl${p}"});
    g‚Çö = gpDef.inflate(p:Mode.*).normalize();
    val fmnDef = if(p === Mode.TE, n / b, -m / a) *
      ‚àö(2 * if(m <> 0 && n <> 0, 2, 1) / (a * b * ((n * œÄ / b)¬≤ + (m * œÄ / a)¬≤))) *
      sin((n * œÄ / b) * (Y - box.ymin)) * cos((m * œÄ / a) * (X - box.xmin)) * box;
    f‚Çò‚Çô = fmnDef.inflate(((m:[0,N<])*(n:[0,N<])*(p:Mode.*)).where((p === Mode.TE && (n <> 0)) || (p === Mode.TM && (m <> 0 && n <> 0))));

    z‚Çò‚Çô = new Vector(f‚Çò‚Çô.size, i->{
      val mm = f‚Çò‚Çô[i].?m as int;
      val nn = f‚Çò‚Çô[i].?n as int;
      val t = f‚Çò‚Çô[i].?t as Mode;
      val ùõæ‚Çó‚Çí = Œª*((mm * œÄ / a)¬≤ + (nn * œÄ / b)¬≤ - (k‚ÇÄ)¬≤ * 1);
      val y‚Çó‚Çí = if (t === TE) (ùõæ‚Çó‚Çí / (I * Œ© * Œº‚ÇÄ)) else (I * Œ© * (Œµ‚ÇÄ * 1) / ùõæ‚Çó‚Çí);
      val ùõæ·¥Ñc = Œª((mm * œÄ / a)¬≤ + (nn * œÄ / b)¬≤ - (k‚ÇÄ)¬≤ * Œµ·µ£);
      val ycc = if (t === TE) (ùõæcc * cotanh(ùõæcc * ep) / (I * Œ© * Œº‚ÇÄ)) else (I * Œ© * Œµ‚ÇÄ * Œµ·µ£) * cotanh(ùõæcc * ep) / ùõæcc;
      return 1 / (y‚Çó‚Çí + ycc));
    })

    s‚Çö = g‚Çö :** f‚Çò‚Çô;

    A = new Matrix(g‚Çö.size(), (i, j) -> ‚àë(f‚Çò‚Çô.size, nn -> s‚Çö[i, nn] * s‚Çö[j, nn] * z‚Çò‚Çô[nn]));
    B = new Matrix(g‚Çö.size(),1, i -> g‚Çö[i] ** srcExpr);
    X‚Çö = A‚Åª¬π*B;
    Z·µ¢‚Çô =(B·µó * (A‚Åª¬π) * B)‚Åª¬π as Complex;
    // discrete scalar product between two vectors is the sum of each primitiveElement3D's product
    J‚Çú= X‚Çö ** g‚Çö ; // (<X‚Çö , g‚Çö>)
    var tt=(X‚Çö :** s‚Çö.columns);
    J‚Çò=(X‚Çö :** s‚Çö.columns) ** f‚Çò‚Çô;
    val yyy=s‚Çö.columns;
    // sum over (q,m,n) of xp*<g‚Çö,f‚Çò‚Çô>*<f‚Çò‚Çô,gq>*z‚Çò‚Çô*f‚Çò‚Çô
    E‚Çò=(X‚Çö :** s‚Çö.columns) ** (z‚Çò‚Çô :* f‚Çò‚Çô);
  }

  /**
    * main function, will call build
    * @param args
    */
  void fun main(String[] args){
    build(freq);
    Plot("s‚Çö").asMatrix().plot(s‚Çö);
    Plot("A").plot(A);
    Plot("B").asMatrix().plot(B);
    Plot("z‚Çò‚Çô").asTable().plot(z‚Çò‚Çô);
    Plot("g‚Çö").domain(box).asCurve().plot(g‚Çö);
    Plot("X‚Çö").asMatrix().plot(X‚Çö);
    Plot("Je").domain(box).asAbs().plot(J‚Çú);
    Plot("J‚Çò").domain(box).asAbs().plot(J‚Çò);
    Plot("E‚Çò").domain(box).asAbs().plot(E‚Çò);
    var frequencies = 1 * GHZ :: 1.0 / 10 * GHZ :: 10 * GHZ;
    var zinlist = new List<Complex>();
    for(fr0 :frequencies){
      zinlist.append(build(fr0));
      Plot.update("|zin|").asCurve().title("Z·µ¢‚Çô (module)").xsamples(frequencies).asAbs.plot(zinlist);
      Plot.update("real(zin)").asCurve().asReal.title("Z·µ¢‚Çô (real part)").xsamples(frequencies).asReal().plot(zinlist);
      Plot.update("image(zin)").asCurve().asReal.title("Z·µ¢‚Çô (imaginary part)").xsamples(frequencies).asImag().plot(zinlist);
    }
  }
}
